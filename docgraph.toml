# docgraph.toml - Document Graph Validation Configuration
# Based on the Dependency Model specification

[graph]
strict_node_types = true
strict_relations  = true
doc_types = ["ACT", "DAT", "IF", "ADR", "TERM", "FC"]

[node_types]
# Core specification types
UC  = { desc = "Use Case" }
FR  = { desc = "Functional Requirement" }
NFR = { desc = "Non-Functional Requirement" }
CON = { desc = "Constraint" }
ERR = { desc = "Error Definition" }

# Architecture types (Core Dependency Model)
CTX = { desc = "Context View Element" }
BB  = { desc = "Building Block" }
RT  = { desc = "Runtime View Scenario" }
DEP = { desc = "Deployment Element" }
CC  = { desc = "Cross-cutting Concept" }

# Documentation types (can be referenced by all core types)
ACT  = { desc = "Actor" }
DAT  = { desc = "Data Entity" }
IF   = { desc = "Interface Specification" }
ADR  = { desc = "Architecture Decision Record" }
TERM = { desc = "Terminology/Glossary" }
FC   = { desc = "Future Consideration" }

# Dependency Model (Derive Flow):
# Business: ACT/IF <- UC
# Spec: UC -> FR -> NFR/ERR, CON -> FR/NFR
# Arch: FR/NFR -> BB, BB -> RT/DEP, ADR -> DEP, CC -> ADR

# ========== Business Relations ==========

[references.UC]
# Use Case derives Actor, Interface, and Requirements
rules = [
  { dir = "to", targets = ["ACT", "IF", "FR", "UC"], min = 0, desc = "Use cases serve as the foundation for actor behavior, interfaces, and functional requirements" }
]

[references.ACT]
# Actor is derived from Use Case
rules = [
  { dir = "from", targets = ["UC"], min = 1, desc = "System actors must be involved in at least one use case to ensure they are defined and relevant" }
]

[references.IF]
# Interface is derived from Use Case
rules = [
  { dir = "from", targets = ["UC"], min = 1, desc = "Exposed interfaces must be justified by business use cases" }
]

# ========== Specification Relations ==========

[references.FR]
# Functional Requirement is derived from Use Case/Constraint and derives further requirements or architecture
rules = [
  { dir = "from", targets = ["UC", "CON"], min = 1, desc = "Functional requirements are derived from business needs (UC) or constraints (CON) to clarify their existence" },
  { dir = "to", targets = ["NFR", "ERR", "BB", "RT", "CC", "IF"], min = 0, desc = "Functional requirements must be traceable to non-functional requirements or detailed designs (BB)" }
]

[references.NFR]
# Non-Functional Requirement is derived from FR/Constraint and derives architecture
rules = [
  { dir = "from", targets = ["FR", "CON"], min = 1, desc = "Non-functional requirements should be defined to meet specific functionality or overall constraints" },
  { dir = "to", targets = ["BB", "CC"], min = 0, desc = "Non-functional requirements must be reflected in specific implementation strategies (BB) or cross-cutting concerns (CC)" }
]

[references.ERR]
# Error is derived from Functional Requirement
rules = [
  { dir = "from", targets = ["FR"], min = 1, desc = "Defined error states must relate to the behavior (abnormal flow) of at least one functional requirement" }
]

[references.CON]
# Constraint derives Functional/Non-Functional Requirements
rules = [
  { dir = "to", targets = ["FR", "NFR"], min = 1, desc = "Constraints must be embodied as specific functional or quality requirements for the system" }
]

# ========== Architecture Relations ==========

[references.CTX]
# Context View derives from Actor or refers to other high-level components for overview
rules = [
  { dir = "to", targets = ["ACT", "UC", "FR", "DAT", "IF", "ADR", "RT"], min = 0, desc = "Context views aggregate major elements from all layers to explain the overall system picture" }
]

[references.BB]
# Building Block is derived from Requirements and derives scenarios/deployment
rules = [
  { dir = "from", targets = ["FR", "NFR"], min = 1, desc = "Design elements (Building Blocks) must exist to satisfy at least one requirement (prevention of over-engineering)" },
  { dir = "to", targets = ["RT", "DEP"], min = 0, desc = "Design elements are defined as runtime behaviors (RT) or deployment units (DEP)" }
]

[references.RT]
# Runtime Scenario is derived from Building Block or Requirement
rules = [
  { dir = "from", targets = ["BB", "FR"], min = 1, desc = "Runtime scenarios must explain the operation of specific design components or functional requirements" }
]

[references.DEP]
# Deployment is derived from Building Block, Architecture Decision, or Concept
rules = [
  { dir = "from", targets = ["BB", "ADR", "CC", "NFR"], min = 1, desc = "Deployment configurations require physical justification based on design (BB), decisions (ADR), or non-functional requirements (NFR)" }
]

[references.CC]
# Cross-cutting Concept is derived from Requirements and derives Decisions
rules = [
  { dir = "from", targets = ["NFR", "FR"], min = 1, desc = "Cross-cutting concerns are derived from requirements to maintain consistency across the entire system" },
  { dir = "to", targets = ["ADR"], min = 0, desc = "Cross-cutting concerns lead to specific architectural decisions (ADR)" }
]

[references.ADR]
# Architecture Decision derives Deployment
rules = [
  { dir = "to", targets = ["DEP"], min = 0, desc = "Architectural decisions influence physical deployment configurations and implementation" }
]
