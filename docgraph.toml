# docgraph.toml - Document Graph Validation Configuration
# Based on the Dependency Model specification

[graph]
ignore = ["README.md", "SECURITY.md", ".agent", ".claude", ".claude-plugin", "docgraph-plugin", "doc/templates"]

# Core specification types
[nodes.UC]
desc = "Use Case"
template = "doc/templates/usecases.md"
rules = [
  { dir = "to", targets = [
    "ACT",
  ], min = 1, desc = "Every use case must identify the initiating participant (Actor) to define scope and responsibility", rel = "triggered_by" },
  { dir = "to", targets = [
    "IF",
  ], min = 1, desc = "Business scenarios must specify their interaction points (Interfaces) to ensure architectural decoupling", rel = "interacts_through" },
  { dir = "to", targets = [
    "FR",
  ], min = 1, desc = "Use cases must be connected to functional outcomes (FR) to maintain business value traceability", rel = "uses" },
]

[nodes.FR]
desc = "Functional Requirement"
template = "doc/templates/functional.md"
rules = [
  { dir = "from", targets = [
    "UC",
  ], min = 1, desc = "Every functional requirement must be driven by at least one business scenario (UC) to ensure user value", rel = "used_by" },
  { dir = "from", targets = [
    "CON",
  ], min = 0, desc = "Functional requirements define how the system must behave within foundational constraints", rel = "constrained_by" },
  { dir = "to", targets = [
    "MOD",
  ], min = 1, desc = "Every requirement must be allocated to a structural component (Module) to ensure no functionality is left unimplemented", rel = "realized_by" },
  { dir = "to", targets = [
    "NFR",
  ], min = 0, desc = "Functional requirements may drive specific quality attribute requirements (NFR)", rel = "qualified_by" },
  { dir = "to", targets = [
    "IF",
  ], min = 0, desc = "Functional requirements may define public API contracts or user interfaces (IF)", rel = "defines" },
  { dir = "to", targets = [
    "CC",
  ], min = 0, desc = "Functional requirements may be reflected in cross-cutting concerns (CC) that apply across multiple modules", rel = "reflected_in" },
]

[nodes.NFR]
desc = "Quality Requirement (Non-Functional)"
template = "doc/templates/non-functional.md"
rules = [
  { dir = "from", targets = [
    "FR",
  ], min = 0, desc = "Quality requirements define the performance or security expectations for functional behavior", rel = "qualifies" },
  { dir = "from", targets = [
    "CON",
  ], min = 0, desc = "Quality requirements define the quality attributes dictated by foundational constraints", rel = "constrained_by" },
  { dir = "to", targets = [
    "CC",
  ], min = 0, desc = "Quality requirements are reflected in cross-cutting designs (CC) that apply across modules", rel = "reflected_in" },
  { dir = "to", targets = [
    "MOD",
  ], min = 0, desc = "Quality requirements may be realized through specific implementation details in modules (MOD)", rel = "realized_by" },
]

[nodes.CON]
desc = "Constraint"
template = "doc/templates/constraint.md"
rules = [
  { dir = "to", targets = [
    "FR",
    "NFR",
  ], min = 1, desc = "Foundational constraints must be embodied in actionable functional or quality requirements to guide system behavior", rel = "constrains" },
]

[nodes.MOD]
desc = "Module"
template = "doc/templates/module.md"
rules = [
  { dir = "from", targets = [
    "FR",
    "NFR",
    "IF",
    "CC",
  ], min = 1, desc = "Every structural module must be justified by at least one requirement or architectural concept to ensure purposeful design", rel = "realized_by" },
]

# Architecture types
[nodes.CC]
desc = "Cross-cutting Concept"
template = "doc/templates/cross-cutting.md"
rules = [
  { dir = "from", targets = [
    "NFR",
    "FR",
  ], min = 0, desc = "Cross-cutting concerns address requirements that span multiple system modules", rel = "reflected_by" },
  { dir = "to", targets = [
    "ADR",
  ], min = 0, desc = "Cross-cutting concern designs lead to specific architectural decisions (ADR)", rel = "justified_by" },
  { dir = "to", targets = [
    "MOD",
  ], min = 0, desc = "Cross-cutting concerns are realized through implementation patterns in specific modules (MOD)", rel = "realized_by" },
]

# Documentation types
[nodes.ACT]
desc = "Actor"
template = "doc/templates/actors.md"
rules = [
  { dir = "from", targets = [
    "*",
  ], min = 0, desc = "Actors represent external entities interacting with the system across various boundary points", rel = "involves" },
  { dir = "from", targets = [
    "UC",
  ], min = 1, desc = "System actors must specify the business scenarios (UC) they participate in", rel = "involved_in" },
]

[nodes.DAT]
desc = "Data Entity"
template = "doc/templates/data.md"
rules = [
  { dir = "from", targets = [
    "*",
  ], min = 0, desc = "Data entities provide shared domain models utilized across multiple system components", rel = "uses_data" },
]

[nodes.IF]
desc = "Interface Specification"
template = "doc/templates/interface.md"
rules = [
  { dir = "from", targets = [
    "*",
  ], min = 0, desc = "System interfaces define the public contracts for communication and integration points", rel = "integrated_with" },
  { dir = "from", targets = [
    "UC",
  ], min = 1, desc = "Exposed interfaces must be justified by at least one business scenario (UC)", rel = "justified_by" },
  { dir = "from", targets = [
    "FR",
  ], min = 1, desc = "Interfaces must be connected to functional requirements to define their behavior", rel = "defined_by" },
  { dir = "to", targets = [
    "MOD",
  ], min = 1, desc = "Every interface specification must be implemented by a module (MOD) to ensure its realization", rel = "realized_by" },
]

[nodes.ADR]
desc = "Architecture Decision Record"
template = "doc/templates/decision.md"
rules = [
  { dir = "from", targets = [
    "*",
  ], min = 0, desc = "Architectural decisions provide the design rationale and historical context for system elements", rel = "informed_by" },
]
