# docgraph.toml - Document Graph Validation Configuration
# Based on the Dependency Model specification

[graph]
doc_types = ["ACT", "DAT", "IF", "ADR"]
ignore = ["README.md", "SECURITY.md", ".claude", ".claude-plugin", "docgraph-plugin", "doc/templates"]

[node_types]
# Core specification types
UC  = { desc = "Use Case", template = "doc/templates/usecases.md" }
FR  = { desc = "Functional Requirement", template = "doc/templates/functional.md" }
NFR = { desc = "Non-Functional Requirement", template = "doc/templates/non-functional.md" }
CON = { desc = "Constraint", template = "doc/templates/constraint.md" }
MOD = { desc = "Module", template = "doc/templates/module.md" }

# Architecture types (Core Dependency Model)
CC  = { desc = "Cross-cutting Concept", template = "doc/templates/cross-cutting.md" }

# Documentation types (can be referenced by all core types)
ACT  = { desc = "Actor", template = "doc/templates/actors.md" }
DAT  = { desc = "Data Entity" }
IF   = { desc = "Interface Specification", template = "doc/templates/interface.md" }
ADR  = { desc = "Architecture Decision Record", template = "doc/templates/decision.md" }

# ========== Business Relations ==========

[references.UC]
# Use Case derives Actor, Interface, and Requirements
rules = [
  { dir = "to", targets = ["ACT"], min = 1, desc = "Use cases must involve at least one Actor", context = "triggered by" },
  { dir = "to", targets = ["IF"], min = 1, desc = "Use cases must interact through at least one Interface", context = "interacts through" },
  { dir = "to", targets = ["FR"], min = 1, desc = "Use cases must realize at least one Functional Requirement", context = "realizes" },
  { dir = "to", targets = ["NFR"], min = 0, desc = "Use cases may relate to NFRs", context = "requires quality" }
]

[references.ACT]
# Actor is derived from Use Case
rules = [
  { dir = "from", targets = ["UC"], min = 1, desc = "System actors must be involved in at least one use case", context = "involved in" }
]

[references.IF]
# Interface is derived from Use Case and Functional Requirement
rules = [
  { dir = "from", targets = ["UC"], min = 1, desc = "Exposed interfaces must be justified by at least one business use case", context = "justified by" },
  { dir = "from", targets = ["FR"], min = 1, desc = "Interfaces must be defined by at least one functional requirement", context = "defined by" },
  { dir = "to", targets = ["MOD"], min = 1, desc = "Interface specifications must be realized by at least one module (MOD) to ensure implementation", context = "realized by" }
]

# ========== Specification Relations ==========

[references.FR]
# Functional Requirement is derived from Use Case/Constraint and derives further requirements or architecture
rules = [
  { dir = "from", targets = ["UC", "CON"], min = 1, desc = "Functional requirements are derived from business needs (UC) or constraints (CON) to clarify their existence", context = "derived from" },
  { dir = "to", targets = ["MOD"], min = 1, desc = "Each functional requirement must be realized by at least one module (MOD) to ensure implementation", context = "realized by" },
  { dir = "to", targets = ["NFR"], min = 0, desc = "Functional requirements may derive non-functional requirements (NFR)", context = "derives" },
  { dir = "to", targets = ["IF"], min = 0, desc = "Functional requirements may define interfaces (IF)", context = "defines" },
  { dir = "to", targets = ["CC"], min = 0, desc = "Functional requirements may be reflected in cross-cutting concerns (CC)", context = "reflected in" }
]

[references.NFR]
# Non-Functional Requirement is derived from UC/FR/Constraint and derives architecture
rules = [
  { dir = "from", targets = ["UC", "FR", "CON"], min = 1, desc = "Non-functional requirements should be defined to meet specific functionality, business needs, or overall constraints", context = "constrained by" },
  { dir = "to", targets = ["CC", "MOD", "NFR"], min = 1, desc = "Non-functional requirements must be reflected in cross-cutting concerns (CC), implementation modules (MOD), or point to other NFRs", context = "satisfied by" }
]

[references.CON]
# Constraint derives Functional/Non-Functional Requirements
rules = [
  { dir = "to", targets = ["FR", "NFR"], min = 1, desc = "Constraints must be embodied as specific functional or quality requirements for the system", context = "embodies" }
]

[references.CC]
# Cross-cutting Concept is derived from Requirements and derives Decisions or is realized by Modules
rules = [
  { dir = "from", targets = ["NFR", "FR"], min = 0, desc = "Cross-cutting concerns are derived from requirements", context = "derived from" },
  { dir = "to", targets = ["ADR"], min = 0, desc = "Cross-cutting concerns lead to specific architectural decisions (ADR)", context = "leads to" },
  { dir = "to", targets = ["MOD"], min = 0, desc = "Cross-cutting concerns may be realized by specific modules (MOD)", context = "realized by" }
]

[references.MOD]
# Module is derived from Functional Requirements, Non-Functional Requirements, Interfaces, or Cross-cutting Concepts
rules = [
  { dir = "from", targets = ["FR", "NFR", "IF", "CC"], min = 1, desc = "Each module must be justified by at least one functional/non-functional requirement, interface, or cross-cutting concept to ensure traceability", context = "justified by" }
]
