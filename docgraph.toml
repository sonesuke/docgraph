# docgraph.toml - Document Graph Validation Configuration
# Based on the Dependency Model specification

[graph]
ignore = ["README.md", "SECURITY.md", ".claude", ".claude-plugin", "docgraph-plugin", "doc/templates"]

# Core specification types
[nodes.UC]
desc = "Use Case"
template = "doc/templates/usecases.md"
rules = [
  { dir = "to", targets = [
    "ACT",
  ], min = 1, desc = "Every use case must identify the initiating participant (Actor) to define scope and responsibility", context = "triggered by" },
  { dir = "to", targets = [
    "IF",
  ], min = 1, desc = "Business scenarios must specify their interaction points (Interfaces) to ensure architectural decoupling", context = "interacts through" },
  { dir = "to", targets = [
    "FR",
  ], min = 1, desc = "Use cases must be connected to functional outcomes (FR) to maintain business value traceability", context = "uses" },
]

[nodes.FR]
desc = "Functional Requirement"
template = "doc/templates/functional.md"
rules = [
  { dir = "from", targets = [
    "UC",
  ], min = 1, desc = "Every functional requirement must be driven by at least one business scenario (UC) to ensure user value", context = "used by" },
  { dir = "from", targets = [
    "CON",
  ], min = 0, desc = "Functional requirements define how the system must behave within foundational constraints", context = "constrained by" },
  { dir = "to", targets = [
    "MOD",
  ], min = 1, desc = "Every requirement must be allocated to a structural component (Module) to ensure no functionality is left unimplemented", context = "implemented by" },
  { dir = "to", targets = [
    "NFR",
  ], min = 0, desc = "Functional requirements may drive specific quality attribute requirements (NFR)", context = "qualified by" },
  { dir = "to", targets = [
    "IF",
  ], min = 0, desc = "Functional requirements may define public API contracts or user interfaces (IF)", context = "defines" },
  { dir = "to", targets = [
    "CC",
  ], min = 0, desc = "Functional requirements may be reflected in cross-cutting concerns (CC) that apply across multiple modules", context = "reflected in" },
]

[nodes.NFR]
desc = "Quality Requirement (Non-Functional)"
template = "doc/templates/non-functional.md"
rules = [
  { dir = "from", targets = [
    "FR",
  ], min = 0, desc = "Quality requirements define the performance or security expectations for functional behavior", context = "qualifies" },
  { dir = "from", targets = [
    "CON",
  ], min = 0, desc = "Quality requirements define the quality attributes dictated by foundational constraints", context = "constrained by" },
  { dir = "to", targets = [
    "CC",
  ], min = 0, desc = "Quality requirements are reflected in cross-cutting designs (CC) that apply across modules", context = "reflected in" },
  { dir = "to", targets = [
    "MOD",
  ], min = 0, desc = "Quality requirements may be realized through specific implementation details in modules (MOD)", context = "implemented by" },
]

[nodes.CON]
desc = "Constraint"
template = "doc/templates/constraint.md"
rules = [
  { dir = "to", targets = [
    "FR",
    "NFR",
  ], min = 1, desc = "Foundational constraints must be embodied in actionable functional or quality requirements to guide system behavior", context = "constrains" },
]

[nodes.MOD]
desc = "Module"
template = "doc/templates/module.md"
rules = [
  { dir = "from", targets = [
    "FR",
    "NFR",
    "IF",
    "CC",
  ], min = 1, desc = "Every structural module must be justified by at least one requirement or architectural concept to ensure purposeful design", context = "implemented by" },
]

# Architecture types
[nodes.CC]
desc = "Cross-cutting Concept"
template = "doc/templates/cross-cutting.md"
rules = [
  { dir = "from", targets = [
    "NFR",
    "FR",
  ], min = 0, desc = "Cross-cutting concerns address requirements that span multiple system modules", context = "reflected by" },
  { dir = "to", targets = [
    "ADR",
  ], min = 0, desc = "Cross-cutting concern designs lead to specific architectural decisions (ADR)", context = "leads to" },
  { dir = "to", targets = [
    "MOD",
  ], min = 0, desc = "Cross-cutting concerns are realized through implementation patterns in specific modules (MOD)", context = "implemented by" },
]

# Documentation types
[nodes.ACT]
desc = "Actor"
template = "doc/templates/actors.md"
rules = [
  { dir = "from", targets = [
    "*",
  ], min = 0, desc = "Actors represent external entities interacting with the system across various boundary points", context = "involved" },
  { dir = "from", targets = [
    "UC",
  ], min = 1, desc = "System actors must specify the business scenarios (UC) they participate in", context = "involved in" },
]

[nodes.DAT]
desc = "Data Entity"
template = "doc/templates/data.md"
rules = [
  { dir = "from", targets = [
    "*",
  ], min = 0, desc = "Data entities provide shared domain models utilized across multiple system components", context = "uses data" },
]

[nodes.IF]
desc = "Interface Specification"
template = "doc/templates/interface.md"
rules = [
  { dir = "from", targets = [
    "*",
  ], min = 0, desc = "System interfaces define the public contracts for communication and integration points", context = "integrated with" },
  { dir = "from", targets = [
    "UC",
  ], min = 1, desc = "Exposed interfaces must be justified by at least one business scenario (UC)", context = "justified by" },
  { dir = "from", targets = [
    "FR",
  ], min = 1, desc = "Interfaces must be connected to functional requirements to define their behavior", context = "defined by" },
  { dir = "to", targets = [
    "MOD",
  ], min = 1, desc = "Every interface specification must be implemented by a module (MOD) to ensure its realization", context = "implemented by" },
]

[nodes.ADR]
desc = "Architecture Decision Record"
template = "doc/templates/decision.md"
rules = [
  { dir = "from", targets = [
    "*",
  ], min = 0, desc = "Architectural decisions provide the design rationale and historical context for system elements", context = "informed by" },
]
